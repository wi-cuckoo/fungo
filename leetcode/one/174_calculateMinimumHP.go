/*
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
为了尽快到达公主，骑士决定每次只向右或向下移动一步。

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。
例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

-2 (K)	-3	3
-5	-10	1
10	30	-5 (P)


说明:

骑士的健康点数没有上限。

任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/dungeon-game
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

package one

import "github.com/wi-cuckoo/fungo/util"

// 按照动态规划的一般想法，我们习惯正向思考，对于到达节点 (i, j) 需要的最少简单点数
// 会与 (i-1, j) 和 (i, j-1) 点有关。如果想成是 f(i,j) = max(f(i,j-1), f(i-1,j))+dungeon(i][j])
// 那就错了，假设房间有三个 [-2, -3, 2]，那么到达第三个点需要的最少点数应该是 5+1，而不是3+1
// 所以，发现正向思考需要处理当前节点为正数的情况，并且还要结合之前节点来考虑，比较复杂

// 于是我们换成逆向思考会有不一样的收获，还是以题中示例为例，
// 			-2  -3	 3
// 			-5  -10	 1
// 			10  30	 -5
// 假设骑士已经处于右下角的点，那么他需要 5 个点才能活下来（为了简化思考，点数为 0 不死）
// 然后倒着看，
// 1. 如果他从正上方来的，那么他处于 (1,2) 时需要 5-1=4 个点才能活
// 2. 如果他从左边来的，那么他处于 (2,1) 时需要 5-30 = -25 个点才能活，但是简单思考下，
//    不需要 -25， 只要为 0 就行了，所以他到这个点并不需要点数就能活着走下去
// 3. 然后另外就是退回到 (1,1)这样的可下可右的点，也可以得出需要最小的存活点数为：
//    min(0, 4)-(-10) = 10 个点就足够了

func calculateMinimumHP(dungeon [][]int) int {
	m, n := len(dungeon), len(dungeon[0])
	// dp[i][j] 表示到达 (i,j) 点的最优路径所消耗的点数
	dp := make([][]int, len(dungeon))
	for i := m - 1; i >= 0; i-- {
		dp[i] = make([]int, n)
		for j := n - 1; j >= 0; j-- {
			if i == m-1 && j == n-1 {
				dp[i][j] = positiveOrZero(0 - dungeon[i][j])
				continue
			}
			if i == m-1 {
				dp[i][j] = positiveOrZero(dp[i][j+1] - dungeon[i][j])
				continue
			}
			if j == n-1 {
				dp[i][j] = positiveOrZero(dp[i+1][j] - dungeon[i][j])
				continue
			}
			val := util.Min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j]
			dp[i][j] = positiveOrZero(val)
		}
	}
	return dp[0][0] + 1
}

func positiveOrZero(i int) int {
	if i < 0 {
		return 0
	}
	return i
}
